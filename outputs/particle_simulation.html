<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vacuum Particle Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
        }

        canvas {
            display: block;
        }

        #overlay {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
        }

        #sub-info {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 5px;
        }
    </style>
</head>

<body>

    <div id="overlay">
        <div>CYLINDRICAL PARTICLE SIMULATION</div>
        <div id="sub-info">25 Particles | Vacuum Physics | Zoom & Rotation</div>
    </div>

    <!-- Import Three.js as an ES Module -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 25,
            cylRadius: 10,
            cylHeight: 30,
            sphereRadius: 25,
            particleRadius: 0.5,
            particleSpeed: 0.3,
            trailLength: 30
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 3);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 100);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);

        // --- Main Container Rotation Group ---
        // Placing everything in a group allows us to rotate the "world" 
        // without calculating rotation physics for every individual particle.
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // 1. Inner Cylinder (The collision boundary)
        const cylGeo = new THREE.CylinderGeometry(CONFIG.cylRadius, CONFIG.cylRadius, CONFIG.cylHeight, 32, 1, true);
        const cylMat = new THREE.MeshBasicMaterial({
            color: 0x00ffcc,
            wireframe: true,
            transparent: true,
            opacity: 0.1,
            side: THREE.DoubleSide
        });
        const cylinder = new THREE.Mesh(cylGeo, cylMat);
        mainGroup.add(cylinder);

        // Cylinder Caps (Visual rings)
        const ringGeo = new THREE.RingGeometry(CONFIG.cylRadius - 0.2, CONFIG.cylRadius, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, side: THREE.DoubleSide });

        const topRing = new THREE.Mesh(ringGeo, ringMat);
        topRing.rotation.x = Math.PI / 2;
        topRing.position.y = CONFIG.cylHeight / 2;
        mainGroup.add(topRing);

        const botRing = new THREE.Mesh(ringGeo, ringMat);
        botRing.rotation.x = Math.PI / 2;
        botRing.position.y = -CONFIG.cylHeight / 2;
        mainGroup.add(botRing);

        // 2. External Sphere (Visual boundary)
        const sphereGeo = new THREE.IcosahedronGeometry(CONFIG.sphereRadius, 3);
        const sphereMat = new THREE.MeshBasicMaterial({
            color: 0x4444ff,
            wireframe: true,
            transparent: true,
            opacity: 0.08
        });
        const outerSphere = new THREE.Mesh(sphereGeo, sphereMat);
        mainGroup.add(outerSphere);

        // --- Particles System ---
        const particles = [];
        const particleGeo = new THREE.SphereGeometry(CONFIG.particleRadius, 16, 16);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            // Random Color
            const color = new THREE.Color().setHSL(Math.random(), 0.9, 0.6);

            // Material
            const mat = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.1,
                metalness: 0.5,
                emissive: color,
                emissiveIntensity: 0.4
            });

            const mesh = new THREE.Mesh(particleGeo, mat);

            // Random Position inside Cylinder
            const angle = Math.random() * Math.PI * 2;
            // Sqrt ensures even distribution within circle
            const r = Math.sqrt(Math.random()) * (CONFIG.cylRadius - CONFIG.particleRadius * 2);

            mesh.position.x = r * Math.cos(angle);
            mesh.position.z = r * Math.sin(angle);
            mesh.position.y = (Math.random() - 0.5) * (CONFIG.cylHeight - CONFIG.particleRadius * 2);

            // Random Velocity (Vacuum = constant speed)
            const velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)
                .normalize()
                .multiplyScalar(CONFIG.particleSpeed);

            mainGroup.add(mesh);

            // --- Trail Setup ---
            const trailBufferPositions = new Float32Array(CONFIG.trailLength * 3);
            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailBufferPositions, 3));

            const trailMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5
            });
            const trailLine = new THREE.Line(trailGeometry, trailMaterial);

            // Initialize trail at starting position
            for (let t = 0; t < CONFIG.trailLength; t++) {
                trailBufferPositions[t * 3] = mesh.position.x;
                trailBufferPositions[t * 3 + 1] = mesh.position.y;
                trailBufferPositions[t * 3 + 2] = mesh.position.z;
            }

            mainGroup.add(trailLine);

            particles.push({
                mesh: mesh,
                velocity: velocity,
                trail: trailLine,
                trailArr: trailBufferPositions
            });
        }

        // --- Physics Logic ---
        function updatePhysics() {
            // Collision Bounds
            const halfH = CONFIG.cylHeight / 2 - CONFIG.particleRadius;
            const maxR = CONFIG.cylRadius - CONFIG.particleRadius;

            particles.forEach(p => {
                // 1. Move
                p.mesh.position.add(p.velocity);

                // 2. Check Top/Bottom Caps (Y-Axis)
                if (p.mesh.position.y > halfH) {
                    p.mesh.position.y = halfH;
                    p.velocity.y *= -1; // Reflect
                } else if (p.mesh.position.y < -halfH) {
                    p.mesh.position.y = -halfH;
                    p.velocity.y *= -1; // Reflect
                }

                // 3. Check Cylinder Walls (XZ Plane)
                // Calculate distance from center
                const distXZ = Math.sqrt(p.mesh.position.x ** 2 + p.mesh.position.z ** 2);

                if (distXZ > maxR) {
                    // Collision Vector (Normal)
                    // The wall normal at point P is simply the direction from center to P (flat Y)
                    const normal = new THREE.Vector3(p.mesh.position.x, 0, p.mesh.position.z).normalize();

                    // Reflect Velocity: V = V - 2(V.N)N
                    const dot = p.velocity.dot(normal);
                    const reflection = normal.clone().multiplyScalar(2 * dot);
                    p.velocity.sub(reflection);

                    // Push position back inside to avoid tunneling
                    // New Pos = Normal * RadiusLimit
                    // We preserve the Y coordinate
                    const correction = normal.clone().multiplyScalar(maxR - 0.01);
                    p.mesh.position.x = correction.x;
                    p.mesh.position.z = correction.z;
                }

                // 4. Update Trail
                const arr = p.trailArr;
                // Shift all points: Drop the oldest (first set), shift rest down
                // Note: To optimize, some implementations use circular buffers, but this is fast enough for <100 pts
                for (let i = 0; i < (CONFIG.trailLength - 1) * 3; i++) {
                    arr[i] = arr[i + 3];
                }
                // Add new point at the end
                const lastIdx = (CONFIG.trailLength - 1) * 3;
                arr[lastIdx] = p.mesh.position.x;
                arr[lastIdx + 1] = p.mesh.position.y;
                arr[lastIdx + 2] = p.mesh.position.z;

                p.trail.geometry.attributes.position.needsUpdate = true;
            });
        }

        // --- Animation Loop ---
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            updatePhysics();

            // Scene effects
            // 1. Zoom In/Out Loop (Sine wave on Z axis)
            // Oscillates between Z=40 and Z=60
            camera.position.z = 50 + Math.sin(time * 0.5) * 10;
            camera.position.y = 10; // Slight angle
            camera.lookAt(0, 0, 0);

            // 2. Slow Container Rotation
            // We rotate the group, so particles and trails move rigidly with the bounds
            mainGroup.rotation.y += 0.005;
            // Slight wobble on Z for "Space" feel
            mainGroup.rotation.z = Math.sin(time * 0.3) * 0.05;

            // 3. External Sphere Counter-Rotation
            outerSphere.rotation.y -= 0.008;

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        animate();

    </script>
</body>

</html>